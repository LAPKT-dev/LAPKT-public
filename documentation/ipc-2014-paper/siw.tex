
The algorithm  \emph{Iterated Width},  or $\IR$,
consists  of a sequence of calls $\IR(i)$ for $i=0,1,\ldots, |F|$
until the problem is solved. Each iteration $\IR(i)$ is a 
breadth-first search that prunes right away  states  that do not pass a   \emph{novelty} test; 
namely, for a state $s$ in $\IR(i)$ \emph{not} to be pruned there must be 
a tuple $t$ of at most $i$ atoms such that $s$ is the first state 
generated in the search that makes $t$ true. The time complexities of $\IR(i)$ and $\IR$
are  $O(n^i)$ and $O(n^w)$ respectively  where $n$ is $|F|$ and $w$ is the problem width.
The width of existing domains is low for atomic goals,  and indeed,  89\% of the  benchmarks
can be solved by $\IR(2)$ when the goal is set to any one of the atoms in the goal \cite{nir:ecai12}.
The width of the benchmark domains with conjunctive goals, however, is not low in general,
yet such problems can be serialized.


The algorithm \emph{Serialized Iterative Width}, or $\SR$, uses $\IR$
for serializing a problem into subproblems and for solving the
subproblems.  SIW uses IW to greedily achieve one atomic goal at a
time until all atomic goals are achieved jointly. In
between, atomic goals may be undone, but after each invocation of IW,
each of the previously achieved goals must hold. SIW will thus never
call IW more than $|G|$ times where $|G|$ is the number of atomic
goals. SIW compares surprisingly well to a baseline heuristic search
planner based on greedy best-first search and the $h_{add}$
heuristic~\cite{bonet:aij-hsp}, but does not approach the performance
of the most recent planners. Nonetheless, $\SR$ competes well in
domains with no dead-ends and simple serializations.
